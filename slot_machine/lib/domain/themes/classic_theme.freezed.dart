// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'classic_theme.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ClassicSymbolValueTearOff {
  const _$ClassicSymbolValueTearOff();

  _Cherry cherry() {
    return const _Cherry();
  }

  _Grapes grapes() {
    return const _Grapes();
  }

  _Strawberry strawberry() {
    return const _Strawberry();
  }

  _Bell bell() {
    return const _Bell();
  }

  _Lemon lemon() {
    return const _Lemon();
  }

  _Melon melon() {
    return const _Melon();
  }

  _Seven seven() {
    return const _Seven();
  }
}

/// @nodoc
const $ClassicSymbolValue = _$ClassicSymbolValueTearOff();

/// @nodoc
mixin _$ClassicSymbolValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClassicSymbolValueCopyWith<$Res> {
  factory $ClassicSymbolValueCopyWith(
          ClassicSymbolValue value, $Res Function(ClassicSymbolValue) then) =
      _$ClassicSymbolValueCopyWithImpl<$Res>;
}

/// @nodoc
class _$ClassicSymbolValueCopyWithImpl<$Res>
    implements $ClassicSymbolValueCopyWith<$Res> {
  _$ClassicSymbolValueCopyWithImpl(this._value, this._then);

  final ClassicSymbolValue _value;
  // ignore: unused_field
  final $Res Function(ClassicSymbolValue) _then;
}

/// @nodoc
abstract class _$CherryCopyWith<$Res> {
  factory _$CherryCopyWith(_Cherry value, $Res Function(_Cherry) then) =
      __$CherryCopyWithImpl<$Res>;
}

/// @nodoc
class __$CherryCopyWithImpl<$Res> extends _$ClassicSymbolValueCopyWithImpl<$Res>
    implements _$CherryCopyWith<$Res> {
  __$CherryCopyWithImpl(_Cherry _value, $Res Function(_Cherry) _then)
      : super(_value, (v) => _then(v as _Cherry));

  @override
  _Cherry get _value => super._value as _Cherry;
}

/// @nodoc

class _$_Cherry extends _Cherry {
  const _$_Cherry() : super._();

  @override
  String toString() {
    return 'ClassicSymbolValue.cherry()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Cherry);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) {
    return cherry();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (cherry != null) {
      return cherry();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) {
    return cherry(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (cherry != null) {
      return cherry(this);
    }
    return orElse();
  }
}

abstract class _Cherry extends ClassicSymbolValue {
  const factory _Cherry() = _$_Cherry;
  const _Cherry._() : super._();
}

/// @nodoc
abstract class _$GrapesCopyWith<$Res> {
  factory _$GrapesCopyWith(_Grapes value, $Res Function(_Grapes) then) =
      __$GrapesCopyWithImpl<$Res>;
}

/// @nodoc
class __$GrapesCopyWithImpl<$Res> extends _$ClassicSymbolValueCopyWithImpl<$Res>
    implements _$GrapesCopyWith<$Res> {
  __$GrapesCopyWithImpl(_Grapes _value, $Res Function(_Grapes) _then)
      : super(_value, (v) => _then(v as _Grapes));

  @override
  _Grapes get _value => super._value as _Grapes;
}

/// @nodoc

class _$_Grapes extends _Grapes {
  const _$_Grapes() : super._();

  @override
  String toString() {
    return 'ClassicSymbolValue.grapes()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Grapes);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) {
    return grapes();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (grapes != null) {
      return grapes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) {
    return grapes(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (grapes != null) {
      return grapes(this);
    }
    return orElse();
  }
}

abstract class _Grapes extends ClassicSymbolValue {
  const factory _Grapes() = _$_Grapes;
  const _Grapes._() : super._();
}

/// @nodoc
abstract class _$StrawberryCopyWith<$Res> {
  factory _$StrawberryCopyWith(
          _Strawberry value, $Res Function(_Strawberry) then) =
      __$StrawberryCopyWithImpl<$Res>;
}

/// @nodoc
class __$StrawberryCopyWithImpl<$Res>
    extends _$ClassicSymbolValueCopyWithImpl<$Res>
    implements _$StrawberryCopyWith<$Res> {
  __$StrawberryCopyWithImpl(
      _Strawberry _value, $Res Function(_Strawberry) _then)
      : super(_value, (v) => _then(v as _Strawberry));

  @override
  _Strawberry get _value => super._value as _Strawberry;
}

/// @nodoc

class _$_Strawberry extends _Strawberry {
  const _$_Strawberry() : super._();

  @override
  String toString() {
    return 'ClassicSymbolValue.strawberry()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Strawberry);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) {
    return strawberry();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (strawberry != null) {
      return strawberry();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) {
    return strawberry(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (strawberry != null) {
      return strawberry(this);
    }
    return orElse();
  }
}

abstract class _Strawberry extends ClassicSymbolValue {
  const factory _Strawberry() = _$_Strawberry;
  const _Strawberry._() : super._();
}

/// @nodoc
abstract class _$BellCopyWith<$Res> {
  factory _$BellCopyWith(_Bell value, $Res Function(_Bell) then) =
      __$BellCopyWithImpl<$Res>;
}

/// @nodoc
class __$BellCopyWithImpl<$Res> extends _$ClassicSymbolValueCopyWithImpl<$Res>
    implements _$BellCopyWith<$Res> {
  __$BellCopyWithImpl(_Bell _value, $Res Function(_Bell) _then)
      : super(_value, (v) => _then(v as _Bell));

  @override
  _Bell get _value => super._value as _Bell;
}

/// @nodoc

class _$_Bell extends _Bell {
  const _$_Bell() : super._();

  @override
  String toString() {
    return 'ClassicSymbolValue.bell()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Bell);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) {
    return bell();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (bell != null) {
      return bell();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) {
    return bell(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (bell != null) {
      return bell(this);
    }
    return orElse();
  }
}

abstract class _Bell extends ClassicSymbolValue {
  const factory _Bell() = _$_Bell;
  const _Bell._() : super._();
}

/// @nodoc
abstract class _$LemonCopyWith<$Res> {
  factory _$LemonCopyWith(_Lemon value, $Res Function(_Lemon) then) =
      __$LemonCopyWithImpl<$Res>;
}

/// @nodoc
class __$LemonCopyWithImpl<$Res> extends _$ClassicSymbolValueCopyWithImpl<$Res>
    implements _$LemonCopyWith<$Res> {
  __$LemonCopyWithImpl(_Lemon _value, $Res Function(_Lemon) _then)
      : super(_value, (v) => _then(v as _Lemon));

  @override
  _Lemon get _value => super._value as _Lemon;
}

/// @nodoc

class _$_Lemon extends _Lemon {
  const _$_Lemon() : super._();

  @override
  String toString() {
    return 'ClassicSymbolValue.lemon()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Lemon);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) {
    return lemon();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (lemon != null) {
      return lemon();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) {
    return lemon(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (lemon != null) {
      return lemon(this);
    }
    return orElse();
  }
}

abstract class _Lemon extends ClassicSymbolValue {
  const factory _Lemon() = _$_Lemon;
  const _Lemon._() : super._();
}

/// @nodoc
abstract class _$MelonCopyWith<$Res> {
  factory _$MelonCopyWith(_Melon value, $Res Function(_Melon) then) =
      __$MelonCopyWithImpl<$Res>;
}

/// @nodoc
class __$MelonCopyWithImpl<$Res> extends _$ClassicSymbolValueCopyWithImpl<$Res>
    implements _$MelonCopyWith<$Res> {
  __$MelonCopyWithImpl(_Melon _value, $Res Function(_Melon) _then)
      : super(_value, (v) => _then(v as _Melon));

  @override
  _Melon get _value => super._value as _Melon;
}

/// @nodoc

class _$_Melon extends _Melon {
  const _$_Melon() : super._();

  @override
  String toString() {
    return 'ClassicSymbolValue.melon()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Melon);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) {
    return melon();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (melon != null) {
      return melon();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) {
    return melon(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (melon != null) {
      return melon(this);
    }
    return orElse();
  }
}

abstract class _Melon extends ClassicSymbolValue {
  const factory _Melon() = _$_Melon;
  const _Melon._() : super._();
}

/// @nodoc
abstract class _$SevenCopyWith<$Res> {
  factory _$SevenCopyWith(_Seven value, $Res Function(_Seven) then) =
      __$SevenCopyWithImpl<$Res>;
}

/// @nodoc
class __$SevenCopyWithImpl<$Res> extends _$ClassicSymbolValueCopyWithImpl<$Res>
    implements _$SevenCopyWith<$Res> {
  __$SevenCopyWithImpl(_Seven _value, $Res Function(_Seven) _then)
      : super(_value, (v) => _then(v as _Seven));

  @override
  _Seven get _value => super._value as _Seven;
}

/// @nodoc

class _$_Seven extends _Seven {
  const _$_Seven() : super._();

  @override
  String toString() {
    return 'ClassicSymbolValue.seven()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Seven);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cherry,
    required TResult Function() grapes,
    required TResult Function() strawberry,
    required TResult Function() bell,
    required TResult Function() lemon,
    required TResult Function() melon,
    required TResult Function() seven,
  }) {
    return seven();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cherry,
    TResult Function()? grapes,
    TResult Function()? strawberry,
    TResult Function()? bell,
    TResult Function()? lemon,
    TResult Function()? melon,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (seven != null) {
      return seven();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Cherry value) cherry,
    required TResult Function(_Grapes value) grapes,
    required TResult Function(_Strawberry value) strawberry,
    required TResult Function(_Bell value) bell,
    required TResult Function(_Lemon value) lemon,
    required TResult Function(_Melon value) melon,
    required TResult Function(_Seven value) seven,
  }) {
    return seven(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Cherry value)? cherry,
    TResult Function(_Grapes value)? grapes,
    TResult Function(_Strawberry value)? strawberry,
    TResult Function(_Bell value)? bell,
    TResult Function(_Lemon value)? lemon,
    TResult Function(_Melon value)? melon,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (seven != null) {
      return seven(this);
    }
    return orElse();
  }
}

abstract class _Seven extends ClassicSymbolValue {
  const factory _Seven() = _$_Seven;
  const _Seven._() : super._();
}
