// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'emoji_theme.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$EmojiValueTearOff {
  const _$EmojiValueTearOff();

  _FaceBlowingAKis faceBlowingAKis() {
    return const _FaceBlowingAKis();
  }

  _FaceWithTongue faceWithTongue() {
    return const _FaceWithTongue();
  }

  _FlushedFace flushedFace() {
    return const _FlushedFace();
  }

  _GrimacingFace grimacingFace() {
    return const _GrimacingFace();
  }

  _GrinningFace grinningFace() {
    return const _GrinningFace();
  }

  _SmilingFaceWithSunglasses smilingFaceWithSunglasses() {
    return const _SmilingFaceWithSunglasses();
  }

  _Poop poop() {
    return const _Poop();
  }
}

/// @nodoc
const $EmojiValue = _$EmojiValueTearOff();

/// @nodoc
mixin _$EmojiValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmojiValueCopyWith<$Res> {
  factory $EmojiValueCopyWith(
          EmojiValue value, $Res Function(EmojiValue) then) =
      _$EmojiValueCopyWithImpl<$Res>;
}

/// @nodoc
class _$EmojiValueCopyWithImpl<$Res> implements $EmojiValueCopyWith<$Res> {
  _$EmojiValueCopyWithImpl(this._value, this._then);

  final EmojiValue _value;
  // ignore: unused_field
  final $Res Function(EmojiValue) _then;
}

/// @nodoc
abstract class _$FaceBlowingAKisCopyWith<$Res> {
  factory _$FaceBlowingAKisCopyWith(
          _FaceBlowingAKis value, $Res Function(_FaceBlowingAKis) then) =
      __$FaceBlowingAKisCopyWithImpl<$Res>;
}

/// @nodoc
class __$FaceBlowingAKisCopyWithImpl<$Res>
    extends _$EmojiValueCopyWithImpl<$Res>
    implements _$FaceBlowingAKisCopyWith<$Res> {
  __$FaceBlowingAKisCopyWithImpl(
      _FaceBlowingAKis _value, $Res Function(_FaceBlowingAKis) _then)
      : super(_value, (v) => _then(v as _FaceBlowingAKis));

  @override
  _FaceBlowingAKis get _value => super._value as _FaceBlowingAKis;
}

/// @nodoc

class _$_FaceBlowingAKis extends _FaceBlowingAKis {
  const _$_FaceBlowingAKis() : super._();

  @override
  String toString() {
    return 'EmojiValue.faceBlowingAKis()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FaceBlowingAKis);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) {
    return faceBlowingAKis();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) {
    if (faceBlowingAKis != null) {
      return faceBlowingAKis();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) {
    return faceBlowingAKis(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) {
    if (faceBlowingAKis != null) {
      return faceBlowingAKis(this);
    }
    return orElse();
  }
}

abstract class _FaceBlowingAKis extends EmojiValue {
  const factory _FaceBlowingAKis() = _$_FaceBlowingAKis;
  const _FaceBlowingAKis._() : super._();
}

/// @nodoc
abstract class _$FaceWithTongueCopyWith<$Res> {
  factory _$FaceWithTongueCopyWith(
          _FaceWithTongue value, $Res Function(_FaceWithTongue) then) =
      __$FaceWithTongueCopyWithImpl<$Res>;
}

/// @nodoc
class __$FaceWithTongueCopyWithImpl<$Res> extends _$EmojiValueCopyWithImpl<$Res>
    implements _$FaceWithTongueCopyWith<$Res> {
  __$FaceWithTongueCopyWithImpl(
      _FaceWithTongue _value, $Res Function(_FaceWithTongue) _then)
      : super(_value, (v) => _then(v as _FaceWithTongue));

  @override
  _FaceWithTongue get _value => super._value as _FaceWithTongue;
}

/// @nodoc

class _$_FaceWithTongue extends _FaceWithTongue {
  const _$_FaceWithTongue() : super._();

  @override
  String toString() {
    return 'EmojiValue.faceWithTongue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FaceWithTongue);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) {
    return faceWithTongue();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) {
    if (faceWithTongue != null) {
      return faceWithTongue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) {
    return faceWithTongue(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) {
    if (faceWithTongue != null) {
      return faceWithTongue(this);
    }
    return orElse();
  }
}

abstract class _FaceWithTongue extends EmojiValue {
  const factory _FaceWithTongue() = _$_FaceWithTongue;
  const _FaceWithTongue._() : super._();
}

/// @nodoc
abstract class _$FlushedFaceCopyWith<$Res> {
  factory _$FlushedFaceCopyWith(
          _FlushedFace value, $Res Function(_FlushedFace) then) =
      __$FlushedFaceCopyWithImpl<$Res>;
}

/// @nodoc
class __$FlushedFaceCopyWithImpl<$Res> extends _$EmojiValueCopyWithImpl<$Res>
    implements _$FlushedFaceCopyWith<$Res> {
  __$FlushedFaceCopyWithImpl(
      _FlushedFace _value, $Res Function(_FlushedFace) _then)
      : super(_value, (v) => _then(v as _FlushedFace));

  @override
  _FlushedFace get _value => super._value as _FlushedFace;
}

/// @nodoc

class _$_FlushedFace extends _FlushedFace {
  const _$_FlushedFace() : super._();

  @override
  String toString() {
    return 'EmojiValue.flushedFace()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FlushedFace);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) {
    return flushedFace();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) {
    if (flushedFace != null) {
      return flushedFace();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) {
    return flushedFace(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) {
    if (flushedFace != null) {
      return flushedFace(this);
    }
    return orElse();
  }
}

abstract class _FlushedFace extends EmojiValue {
  const factory _FlushedFace() = _$_FlushedFace;
  const _FlushedFace._() : super._();
}

/// @nodoc
abstract class _$GrimacingFaceCopyWith<$Res> {
  factory _$GrimacingFaceCopyWith(
          _GrimacingFace value, $Res Function(_GrimacingFace) then) =
      __$GrimacingFaceCopyWithImpl<$Res>;
}

/// @nodoc
class __$GrimacingFaceCopyWithImpl<$Res> extends _$EmojiValueCopyWithImpl<$Res>
    implements _$GrimacingFaceCopyWith<$Res> {
  __$GrimacingFaceCopyWithImpl(
      _GrimacingFace _value, $Res Function(_GrimacingFace) _then)
      : super(_value, (v) => _then(v as _GrimacingFace));

  @override
  _GrimacingFace get _value => super._value as _GrimacingFace;
}

/// @nodoc

class _$_GrimacingFace extends _GrimacingFace {
  const _$_GrimacingFace() : super._();

  @override
  String toString() {
    return 'EmojiValue.grimacingFace()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _GrimacingFace);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) {
    return grimacingFace();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) {
    if (grimacingFace != null) {
      return grimacingFace();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) {
    return grimacingFace(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) {
    if (grimacingFace != null) {
      return grimacingFace(this);
    }
    return orElse();
  }
}

abstract class _GrimacingFace extends EmojiValue {
  const factory _GrimacingFace() = _$_GrimacingFace;
  const _GrimacingFace._() : super._();
}

/// @nodoc
abstract class _$GrinningFaceCopyWith<$Res> {
  factory _$GrinningFaceCopyWith(
          _GrinningFace value, $Res Function(_GrinningFace) then) =
      __$GrinningFaceCopyWithImpl<$Res>;
}

/// @nodoc
class __$GrinningFaceCopyWithImpl<$Res> extends _$EmojiValueCopyWithImpl<$Res>
    implements _$GrinningFaceCopyWith<$Res> {
  __$GrinningFaceCopyWithImpl(
      _GrinningFace _value, $Res Function(_GrinningFace) _then)
      : super(_value, (v) => _then(v as _GrinningFace));

  @override
  _GrinningFace get _value => super._value as _GrinningFace;
}

/// @nodoc

class _$_GrinningFace extends _GrinningFace {
  const _$_GrinningFace() : super._();

  @override
  String toString() {
    return 'EmojiValue.grinningFace()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _GrinningFace);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) {
    return grinningFace();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) {
    if (grinningFace != null) {
      return grinningFace();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) {
    return grinningFace(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) {
    if (grinningFace != null) {
      return grinningFace(this);
    }
    return orElse();
  }
}

abstract class _GrinningFace extends EmojiValue {
  const factory _GrinningFace() = _$_GrinningFace;
  const _GrinningFace._() : super._();
}

/// @nodoc
abstract class _$SmilingFaceWithSunglassesCopyWith<$Res> {
  factory _$SmilingFaceWithSunglassesCopyWith(_SmilingFaceWithSunglasses value,
          $Res Function(_SmilingFaceWithSunglasses) then) =
      __$SmilingFaceWithSunglassesCopyWithImpl<$Res>;
}

/// @nodoc
class __$SmilingFaceWithSunglassesCopyWithImpl<$Res>
    extends _$EmojiValueCopyWithImpl<$Res>
    implements _$SmilingFaceWithSunglassesCopyWith<$Res> {
  __$SmilingFaceWithSunglassesCopyWithImpl(_SmilingFaceWithSunglasses _value,
      $Res Function(_SmilingFaceWithSunglasses) _then)
      : super(_value, (v) => _then(v as _SmilingFaceWithSunglasses));

  @override
  _SmilingFaceWithSunglasses get _value =>
      super._value as _SmilingFaceWithSunglasses;
}

/// @nodoc

class _$_SmilingFaceWithSunglasses extends _SmilingFaceWithSunglasses {
  const _$_SmilingFaceWithSunglasses() : super._();

  @override
  String toString() {
    return 'EmojiValue.smilingFaceWithSunglasses()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SmilingFaceWithSunglasses);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) {
    return smilingFaceWithSunglasses();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) {
    if (smilingFaceWithSunglasses != null) {
      return smilingFaceWithSunglasses();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) {
    return smilingFaceWithSunglasses(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) {
    if (smilingFaceWithSunglasses != null) {
      return smilingFaceWithSunglasses(this);
    }
    return orElse();
  }
}

abstract class _SmilingFaceWithSunglasses extends EmojiValue {
  const factory _SmilingFaceWithSunglasses() = _$_SmilingFaceWithSunglasses;
  const _SmilingFaceWithSunglasses._() : super._();
}

/// @nodoc
abstract class _$PoopCopyWith<$Res> {
  factory _$PoopCopyWith(_Poop value, $Res Function(_Poop) then) =
      __$PoopCopyWithImpl<$Res>;
}

/// @nodoc
class __$PoopCopyWithImpl<$Res> extends _$EmojiValueCopyWithImpl<$Res>
    implements _$PoopCopyWith<$Res> {
  __$PoopCopyWithImpl(_Poop _value, $Res Function(_Poop) _then)
      : super(_value, (v) => _then(v as _Poop));

  @override
  _Poop get _value => super._value as _Poop;
}

/// @nodoc

class _$_Poop extends _Poop {
  const _$_Poop() : super._();

  @override
  String toString() {
    return 'EmojiValue.poop()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Poop);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() faceBlowingAKis,
    required TResult Function() faceWithTongue,
    required TResult Function() flushedFace,
    required TResult Function() grimacingFace,
    required TResult Function() grinningFace,
    required TResult Function() smilingFaceWithSunglasses,
    required TResult Function() poop,
  }) {
    return poop();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? faceBlowingAKis,
    TResult Function()? faceWithTongue,
    TResult Function()? flushedFace,
    TResult Function()? grimacingFace,
    TResult Function()? grinningFace,
    TResult Function()? smilingFaceWithSunglasses,
    TResult Function()? poop,
    required TResult orElse(),
  }) {
    if (poop != null) {
      return poop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FaceBlowingAKis value) faceBlowingAKis,
    required TResult Function(_FaceWithTongue value) faceWithTongue,
    required TResult Function(_FlushedFace value) flushedFace,
    required TResult Function(_GrimacingFace value) grimacingFace,
    required TResult Function(_GrinningFace value) grinningFace,
    required TResult Function(_SmilingFaceWithSunglasses value)
        smilingFaceWithSunglasses,
    required TResult Function(_Poop value) poop,
  }) {
    return poop(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FaceBlowingAKis value)? faceBlowingAKis,
    TResult Function(_FaceWithTongue value)? faceWithTongue,
    TResult Function(_FlushedFace value)? flushedFace,
    TResult Function(_GrimacingFace value)? grimacingFace,
    TResult Function(_GrinningFace value)? grinningFace,
    TResult Function(_SmilingFaceWithSunglasses value)?
        smilingFaceWithSunglasses,
    TResult Function(_Poop value)? poop,
    required TResult orElse(),
  }) {
    if (poop != null) {
      return poop(this);
    }
    return orElse();
  }
}

abstract class _Poop extends EmojiValue {
  const factory _Poop() = _$_Poop;
  const _Poop._() : super._();
}
