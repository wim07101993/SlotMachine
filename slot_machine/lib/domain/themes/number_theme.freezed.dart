// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'number_theme.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$NumberValueTearOff {
  const _$NumberValueTearOff();

  _One one() {
    return const _One();
  }

  _Two two() {
    return const _Two();
  }

  _Three three() {
    return const _Three();
  }

  _Four four() {
    return const _Four();
  }

  _Five five() {
    return const _Five();
  }

  _Six six() {
    return const _Six();
  }

  _Seven seven() {
    return const _Seven();
  }
}

/// @nodoc
const $NumberValue = _$NumberValueTearOff();

/// @nodoc
mixin _$NumberValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NumberValueCopyWith<$Res> {
  factory $NumberValueCopyWith(
          NumberValue value, $Res Function(NumberValue) then) =
      _$NumberValueCopyWithImpl<$Res>;
}

/// @nodoc
class _$NumberValueCopyWithImpl<$Res> implements $NumberValueCopyWith<$Res> {
  _$NumberValueCopyWithImpl(this._value, this._then);

  final NumberValue _value;
  // ignore: unused_field
  final $Res Function(NumberValue) _then;
}

/// @nodoc
abstract class _$OneCopyWith<$Res> {
  factory _$OneCopyWith(_One value, $Res Function(_One) then) =
      __$OneCopyWithImpl<$Res>;
}

/// @nodoc
class __$OneCopyWithImpl<$Res> extends _$NumberValueCopyWithImpl<$Res>
    implements _$OneCopyWith<$Res> {
  __$OneCopyWithImpl(_One _value, $Res Function(_One) _then)
      : super(_value, (v) => _then(v as _One));

  @override
  _One get _value => super._value as _One;
}

/// @nodoc

class _$_One extends _One {
  const _$_One() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _One);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) {
    return one();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (one != null) {
      return one();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) {
    return one(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (one != null) {
      return one(this);
    }
    return orElse();
  }
}

abstract class _One extends NumberValue {
  const factory _One() = _$_One;
  const _One._() : super._();
}

/// @nodoc
abstract class _$TwoCopyWith<$Res> {
  factory _$TwoCopyWith(_Two value, $Res Function(_Two) then) =
      __$TwoCopyWithImpl<$Res>;
}

/// @nodoc
class __$TwoCopyWithImpl<$Res> extends _$NumberValueCopyWithImpl<$Res>
    implements _$TwoCopyWith<$Res> {
  __$TwoCopyWithImpl(_Two _value, $Res Function(_Two) _then)
      : super(_value, (v) => _then(v as _Two));

  @override
  _Two get _value => super._value as _Two;
}

/// @nodoc

class _$_Two extends _Two {
  const _$_Two() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Two);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) {
    return two();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (two != null) {
      return two();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) {
    return two(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (two != null) {
      return two(this);
    }
    return orElse();
  }
}

abstract class _Two extends NumberValue {
  const factory _Two() = _$_Two;
  const _Two._() : super._();
}

/// @nodoc
abstract class _$ThreeCopyWith<$Res> {
  factory _$ThreeCopyWith(_Three value, $Res Function(_Three) then) =
      __$ThreeCopyWithImpl<$Res>;
}

/// @nodoc
class __$ThreeCopyWithImpl<$Res> extends _$NumberValueCopyWithImpl<$Res>
    implements _$ThreeCopyWith<$Res> {
  __$ThreeCopyWithImpl(_Three _value, $Res Function(_Three) _then)
      : super(_value, (v) => _then(v as _Three));

  @override
  _Three get _value => super._value as _Three;
}

/// @nodoc

class _$_Three extends _Three {
  const _$_Three() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Three);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) {
    return three();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (three != null) {
      return three();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) {
    return three(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (three != null) {
      return three(this);
    }
    return orElse();
  }
}

abstract class _Three extends NumberValue {
  const factory _Three() = _$_Three;
  const _Three._() : super._();
}

/// @nodoc
abstract class _$FourCopyWith<$Res> {
  factory _$FourCopyWith(_Four value, $Res Function(_Four) then) =
      __$FourCopyWithImpl<$Res>;
}

/// @nodoc
class __$FourCopyWithImpl<$Res> extends _$NumberValueCopyWithImpl<$Res>
    implements _$FourCopyWith<$Res> {
  __$FourCopyWithImpl(_Four _value, $Res Function(_Four) _then)
      : super(_value, (v) => _then(v as _Four));

  @override
  _Four get _value => super._value as _Four;
}

/// @nodoc

class _$_Four extends _Four {
  const _$_Four() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Four);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) {
    return four();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (four != null) {
      return four();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) {
    return four(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (four != null) {
      return four(this);
    }
    return orElse();
  }
}

abstract class _Four extends NumberValue {
  const factory _Four() = _$_Four;
  const _Four._() : super._();
}

/// @nodoc
abstract class _$FiveCopyWith<$Res> {
  factory _$FiveCopyWith(_Five value, $Res Function(_Five) then) =
      __$FiveCopyWithImpl<$Res>;
}

/// @nodoc
class __$FiveCopyWithImpl<$Res> extends _$NumberValueCopyWithImpl<$Res>
    implements _$FiveCopyWith<$Res> {
  __$FiveCopyWithImpl(_Five _value, $Res Function(_Five) _then)
      : super(_value, (v) => _then(v as _Five));

  @override
  _Five get _value => super._value as _Five;
}

/// @nodoc

class _$_Five extends _Five {
  const _$_Five() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Five);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) {
    return five();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (five != null) {
      return five();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) {
    return five(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (five != null) {
      return five(this);
    }
    return orElse();
  }
}

abstract class _Five extends NumberValue {
  const factory _Five() = _$_Five;
  const _Five._() : super._();
}

/// @nodoc
abstract class _$SixCopyWith<$Res> {
  factory _$SixCopyWith(_Six value, $Res Function(_Six) then) =
      __$SixCopyWithImpl<$Res>;
}

/// @nodoc
class __$SixCopyWithImpl<$Res> extends _$NumberValueCopyWithImpl<$Res>
    implements _$SixCopyWith<$Res> {
  __$SixCopyWithImpl(_Six _value, $Res Function(_Six) _then)
      : super(_value, (v) => _then(v as _Six));

  @override
  _Six get _value => super._value as _Six;
}

/// @nodoc

class _$_Six extends _Six {
  const _$_Six() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Six);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) {
    return six();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (six != null) {
      return six();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) {
    return six(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (six != null) {
      return six(this);
    }
    return orElse();
  }
}

abstract class _Six extends NumberValue {
  const factory _Six() = _$_Six;
  const _Six._() : super._();
}

/// @nodoc
abstract class _$SevenCopyWith<$Res> {
  factory _$SevenCopyWith(_Seven value, $Res Function(_Seven) then) =
      __$SevenCopyWithImpl<$Res>;
}

/// @nodoc
class __$SevenCopyWithImpl<$Res> extends _$NumberValueCopyWithImpl<$Res>
    implements _$SevenCopyWith<$Res> {
  __$SevenCopyWithImpl(_Seven _value, $Res Function(_Seven) _then)
      : super(_value, (v) => _then(v as _Seven));

  @override
  _Seven get _value => super._value as _Seven;
}

/// @nodoc

class _$_Seven extends _Seven {
  const _$_Seven() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Seven);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() one,
    required TResult Function() two,
    required TResult Function() three,
    required TResult Function() four,
    required TResult Function() five,
    required TResult Function() six,
    required TResult Function() seven,
  }) {
    return seven();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? one,
    TResult Function()? two,
    TResult Function()? three,
    TResult Function()? four,
    TResult Function()? five,
    TResult Function()? six,
    TResult Function()? seven,
    required TResult orElse(),
  }) {
    if (seven != null) {
      return seven();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_One value) one,
    required TResult Function(_Two value) two,
    required TResult Function(_Three value) three,
    required TResult Function(_Four value) four,
    required TResult Function(_Five value) five,
    required TResult Function(_Six value) six,
    required TResult Function(_Seven value) seven,
  }) {
    return seven(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_One value)? one,
    TResult Function(_Two value)? two,
    TResult Function(_Three value)? three,
    TResult Function(_Four value)? four,
    TResult Function(_Five value)? five,
    TResult Function(_Six value)? six,
    TResult Function(_Seven value)? seven,
    required TResult orElse(),
  }) {
    if (seven != null) {
      return seven(this);
    }
    return orElse();
  }
}

abstract class _Seven extends NumberValue {
  const factory _Seven() = _$_Seven;
  const _Seven._() : super._();
}
